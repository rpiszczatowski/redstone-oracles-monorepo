#include "stdlib.fc";
#include "constants.fc";

(int) tlen (tuple t) asm "TLEN";
forall X -> (tuple, X) ~tpop (tuple t) asm "TPOP";

(int)index_of(tuple vec, int value) {
    int k = 0;
    while (vec.tlen() > 0) {
        if (vec~tpop() == value) {
            return k;
        }
        k += 1;
    }

    return -1;
}


(tuple)sort(tuple vec) {
    tuple res = empty_tuple();

    repeat (vec.tlen()) {
        tuple tmp = empty_tuple();
        int min_elt = vec~tpop();

        while (vec.tlen() > 0) {
            (min_elt, int b) = minmax(min_elt, vec~tpop());

            tmp~tpush(b);
        }

        res~tpush(min_elt);
        vec = tmp;
    }

    return res;
}

(int)median(tuple vec) {
    int n = vec.tlen();

    throw_unless(ERR_TUPLE_EMPTY, n > 0);

    if(n == 1) {
        return vec.first();
    } else {
        var (q, r) = (n / 2, n % 2);
        tuple sorted = vec.sort();

        if (r == 1) {
            return sorted.at(q);
        } else {
            return (sorted.at(q) + sorted.at(q - 1)) / 2;
        }
    }
}

(cell)tuple_to_cell(tuple t, int value_size) {
    int values_per_cell = (1023 / value_size);
    builder res = begin_cell();

    builder tmp = begin_cell();
    int i = 0;
    while (i < t.tlen()) {
        tmp~store_int(t.at(i), value_size);
        i += 1;

        if(i % values_per_cell == 0) {
            if (i > values_per_cell) {
                res = res.store_ref(tmp.end_cell());
            } else {
                res = res.store_builder(tmp);
            }
            tmp = begin_cell();
        }
    }

    if (i > values_per_cell) {
        res = res.store_ref(tmp.end_cell());
    }

    return res.end_cell();
}
